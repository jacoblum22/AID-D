"""
LLM-based narration generator for AID&D prototype.

This module takes structured ToolResult data and game state, then uses
4o-mini to generate immersive, literary narration that goes beyond
the deterministic templates used in tools.
"""

import json
import logging
from typing import Dict, Any, Optional, List
from textwrap import dedent

from openai import OpenAI
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
)

from backend.router.game_state import GameState
from backend.router.validator import ToolResult
from backend.router.visibility import redact_entity, redact_zone
import config


# Set up logging
logger = logging.getLogger(__name__)


class NarrationGenerator:
    """Generates rich narration using 4o-mini from structured tool results."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        model: str = "gpt-4o-mini",
        max_tokens: int = 150,
        temperature: float = 0.7,
    ):
        """Initialize the narration generator."""
        self.client = OpenAI(api_key=api_key or config.OPENAI_API_KEY)
        self.model = model
        self.max_tokens = max_tokens
        self.temperature = temperature

        # Base system prompt for narration role
        self.system_prompt = dedent(
            """
            You are the Dungeon Master of an AI tabletop RPG.
            Your task is to narrate what happens, given structured data from game mechanics.

            CRITICAL RULES:
            - Write 1-3 sentences of immersive, literary narration
            - Use sensory detail and atmospheric language
            - Stay consistent with the provided facts - do NOT invent new mechanics or outcomes
            - Do NOT reveal hidden or GM-only information
            - Match the tone indicated by tone_tags
            - Focus on the player's perspective and experience
            - Avoid repetitive language and clichÃ©s
            - Make it feel like reading a fantasy novel

            Your narration should feel organic and creative while respecting the mechanical reality.
        """
        ).strip()

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=5),
        retry=retry_if_exception_type(Exception),
    )
    def generate_narration(
        self, result: ToolResult, world: GameState, pov_actor_id: Optional[str] = None
    ) -> str:
        """
        Generate rich narration from a tool result.

        Args:
            result: The ToolResult from tool execution
            world: Current game state for context
            pov_actor_id: ID of the POV actor (defaults to current_actor)

        Returns:
            Rich narrative text generated by 4o-mini
        """
        try:
            # Determine POV actor
            pov_id = pov_actor_id or world.current_actor
            if not pov_id:
                return result.narration_hint.get("summary", "Something happens.")

            # Get redacted world state for safety
            redacted_state = world.get_state(pov_id, redact=True)

            # Build context for the LLM
            context = self._build_context(result, redacted_state, pov_id)

            # Create the prompt
            user_prompt = self._create_prompt(result, context)

            # Call LLM
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_prompt},
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature,
            )

            narration = response.choices[0].message.content
            if narration:
                return narration.strip()
            else:
                return result.narration_hint.get("summary", "Something happens.")

        except Exception as e:
            logger.error(f"Narration generation failed: {e}")
            # Fallback to original summary
            return result.narration_hint.get("summary", "Something happens.")

    def _build_context(
        self, result: ToolResult, redacted_state: Dict[str, Any], pov_id: str
    ) -> Dict[str, Any]:
        """Build safe context information for the LLM."""

        # Get POV actor info
        pov_actor = redacted_state.get("actors", {}).get(pov_id, {})
        pov_name = pov_actor.get("name", "You")

        # Get current zone info
        current_zone_id = pov_actor.get("current_zone")
        current_zone = redacted_state.get("zones", {}).get(current_zone_id, {})
        zone_name = current_zone.get("name", "an unknown location")
        zone_description = current_zone.get("description", "")

        # Get visible entities in the zone
        visible_entities = []
        zone_actors = current_zone.get("actors", [])
        for actor_id in zone_actors:
            if actor_id != pov_id:  # Don't include self
                actor = redacted_state.get("actors", {}).get(actor_id, {})
                if actor:
                    visible_entities.append(
                        {
                            "id": actor_id,
                            "name": actor.get("name", "unknown entity"),
                            "type": actor.get("entity_type", "unknown"),
                        }
                    )

        # Get scene atmosphere
        scene = redacted_state.get("scene", {})
        scene_tags = scene.get("tags", {})

        return {
            "pov_actor": {
                "id": pov_id,
                "name": pov_name,
                "hp": pov_actor.get("hp", {}).get("current", "unknown"),
                "max_hp": pov_actor.get("hp", {}).get("max", "unknown"),
            },
            "current_zone": {
                "id": current_zone_id,
                "name": zone_name,
                "description": zone_description,
                "visible_entities": visible_entities,
            },
            "scene": {
                "round": scene.get("round", 1),
                "tags": scene_tags,
            },
        }

    def _create_prompt(self, result: ToolResult, context: Dict[str, Any]) -> str:
        """Create the prompt for LLM narration generation."""

        # Extract key information
        tool_id = result.tool_id
        facts = result.facts
        narration_hint = result.narration_hint
        effects = result.effects

        # Get tone guidance
        tone_tags = narration_hint.get("tone_tags", [])
        sensory_focus = narration_hint.get("sensory", [])

        # Build effects summary if there are any
        effects_summary = ""
        if effects:
            effects_summary = f"\\nMechanical changes: {len(effects)} effects applied"
            # Add brief summary of major effects
            hp_changes = [e for e in effects if e.get("type") == "hp"]
            if hp_changes:
                effects_summary += f" (including HP changes)"

        prompt = dedent(
            f"""
            [Tool Executed]: {tool_id}
            
            [Player Character]: {context['pov_actor']['name']} (HP: {context['pov_actor']['hp']}/{context['pov_actor']['max_hp']})
            
            [Current Location]: {context['current_zone']['name']}
            {context['current_zone']['description']}
            
            [Visible Entities]: {', '.join([e['name'] for e in context['current_zone']['visible_entities']]) or 'None'}
            
            [Scene Atmosphere]: Round {context['scene']['round']}
            Tags: {', '.join([f"{k}={v}" for k, v in context['scene']['tags'].items()]) or 'normal'}
            
            [What Happened - Raw Facts]:
            {json.dumps(facts, indent=2)}
            
            [Tone Guidance]: {', '.join(tone_tags) if tone_tags else 'neutral'}
            [Sensory Focus]: {', '.join(sensory_focus) if sensory_focus else 'visual'}
            
            [Original Summary]: {narration_hint.get('summary', 'No summary provided')}
            {effects_summary}
            
            Write immersive narration for what just happened from {context['pov_actor']['name']}'s perspective.
            Use the tone guidance and sensory focus. Be creative but stay true to the facts.
        """
        ).strip()

        return prompt


# Global generator instance
_generator_instance: Optional[NarrationGenerator] = None


def initialize_generator(
    api_key: Optional[str] = None, model: str = "gpt-4o-mini"
) -> None:
    """Initialize the global narration generator."""
    global _generator_instance
    _generator_instance = NarrationGenerator(api_key=api_key, model=model)


def generate_narration(
    result: ToolResult, world: GameState, pov_actor_id: Optional[str] = None
) -> str:
    """
    Convenience function to generate narration using the global generator.

    Args:
        result: ToolResult from tool execution
        world: Current game state
        pov_actor_id: Optional POV actor ID

    Returns:
        Rich narrative text
    """
    global _generator_instance
    if _generator_instance is None:
        # Auto-initialize with config defaults
        initialize_generator()

    # Double-check initialization succeeded
    if _generator_instance is None:
        logger.error("Failed to initialize narration generator")
        return result.narration_hint.get("summary", "Something happens.")

    return _generator_instance.generate_narration(result, world, pov_actor_id)
