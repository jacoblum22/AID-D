"""
LLM-based narration generator for AID&D prototype.

This module takes structured ToolResult data and game state, then uses
4o-mini to generate immersive, literary narration that goes beyond
the deterministic templates used in tools.
"""

import json
import logging
from typing import Dict, Any, Optional, List
from textwrap import dedent

from openai import OpenAI
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type,
)

from backend.router.game_state import GameState
from backend.router.validator import ToolResult
from backend.router.visibility import redact_entity, redact_zone
from backend.router.zone_graph import is_zone_discovered
import config


# Set up logging
logger = logging.getLogger(__name__)


class NarrationGenerator:
    """Generates rich narration using 4o-mini from structured tool results."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        model: str = "gpt-4o-mini",
        max_tokens: int = 150,
        temperature: float = 0.7,
    ):
        """Initialize the narration generator."""
        self.client = OpenAI(api_key=api_key or config.OPENAI_API_KEY)
        self.model = model
        self.max_tokens = max_tokens
        self.temperature = temperature

        # Base system prompt for narration role
        self.system_prompt = dedent(
            """
            You are the Dungeon Master of an AI tabletop RPG.
            Your task is to narrate what happens, given structured data from game mechanics.

            CRITICAL RULES:
            - Write 1-3 sentences of immersive, literary narration
            - Use sensory detail and atmospheric language
            - Stay consistent with the provided facts - do NOT invent new mechanics or outcomes
            - Do NOT reveal hidden or GM-only information
            - Match the tone indicated by tone_tags
            - Focus on the player's perspective and experience
            - Avoid repetitive language and clichÃ©s
            - Make it feel like reading a fantasy novel

            Your narration should feel organic and creative while respecting the mechanical reality.
        """
        ).strip()

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=5),
        retry=retry_if_exception_type(Exception),
    )
    def generate_narration(
        self,
        result: ToolResult,
        world: GameState,
        pov_actor_id: Optional[str] = None,
        previous_narration: str = "",
    ) -> str:
        """
        Generate rich narration from a tool result.

        Args:
            result: The ToolResult from tool execution
            world: Current game state for context
            pov_actor_id: ID of the POV actor (defaults to current_actor)
            previous_narration: Previous narration text for continuity

        Returns:
            Rich narrative text generated by 4o-mini
        """
        try:
            # Determine POV actor
            pov_id = pov_actor_id or world.current_actor
            if not pov_id:
                return result.narration_hint.get("summary", "Something happens.")

            # Get redacted world state for safety - disable cache to avoid stale visibility
            redacted_state = world.get_state(
                pov_id, redact=True, role="player", use_cache=False
            )

            # Build context for the LLM
            context = self._build_context(result, redacted_state, pov_id, world)

            # Create the prompt
            user_prompt = self._create_prompt(result, context, previous_narration)

            # Call LLM
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_prompt},
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature,
            )

            narration = response.choices[0].message.content
            if narration:
                return narration.strip()
            else:
                return result.narration_hint.get("summary", "Something happens.")

        except Exception as e:
            logger.error(f"Narration generation failed: {e}")
            # Fallback to original summary
            return result.narration_hint.get("summary", "Something happens.")

    def _build_context(
        self,
        result: ToolResult,
        redacted_state: Dict[str, Any],
        pov_id: str,
        world: GameState,
    ) -> Dict[str, Any]:
        """Build safe context information for the LLM."""

        # Get POV actor info
        pov_actor = redacted_state.get("actors", {}).get(pov_id, {})
        pov_name = pov_actor.get("name", "You")

        # For move actions, we need to describe the DESTINATION zone, not current zone
        # because narration runs before position effects are applied
        if result.tool_id == "move" and result.facts and "to_zone" in result.facts:
            # Use destination zone for movement narration
            target_zone_id = result.facts["to_zone"]
            target_zone = redacted_state.get("zones", {}).get(target_zone_id, {})
            zone_name = target_zone.get("name", "an unknown location")
            zone_description = target_zone.get("description", "")

            # Check if this is the first time entering this zone
            is_first_visit = not is_zone_discovered(pov_id, target_zone_id, world)

            # Get actors in the DESTINATION zone (including NPCs the player will encounter)
            visible_entities = []
            # The redacted state adds an 'entities' field with visible entity IDs in the zone
            zone_actors = target_zone.get("entities", [])

            for actor_id in zone_actors:
                if actor_id != pov_id:  # Don't include self
                    # Try both 'actors' and 'entities' fields for entity data
                    actor = redacted_state.get("actors", {}).get(
                        actor_id, {}
                    ) or redacted_state.get("entities", {}).get(actor_id, {})
                    if actor:
                        entity_info = {
                            "id": actor_id,
                            "name": actor.get("name", "unknown entity"),
                            "type": actor.get("entity_type", "unknown"),
                        }

                        # Check if entity is dead (HP = 0) and mark for special narration (MOVE ACTION)
                        hp = actor.get("hp", {})
                        current_hp = None
                        if isinstance(hp, dict):
                            current_hp = hp.get("current")

                        # Only check for death if we have valid HP data
                        if current_hp is not None and current_hp <= 0:
                            entity_info["is_dead"] = True
                            entity_info["description"] = (
                                f"the body of {entity_info['name']}"
                            )
                        else:
                            entity_info["is_dead"] = False

                        visible_entities.append(entity_info)

            context_zone_id = target_zone_id
        else:
            # For non-move actions, use current zone
            current_zone_id = pov_actor.get("current_zone")
            current_zone = redacted_state.get("zones", {}).get(current_zone_id, {})
            zone_name = current_zone.get("name", "an unknown location")
            zone_description = current_zone.get("description", "")

            # For non-move actions, zone is already known (not first visit)
            is_first_visit = False

            # Get visible entities in the current zone
            visible_entities = []
            # The redacted state adds an 'entities' field with visible entity IDs in the zone
            zone_actors = current_zone.get("entities", [])
            for actor_id in zone_actors:
                if actor_id != pov_id:  # Don't include self
                    # Try both 'actors' and 'entities' fields for entity data
                    actor = redacted_state.get("actors", {}).get(
                        actor_id, {}
                    ) or redacted_state.get("entities", {}).get(actor_id, {})
                    if actor:
                        entity_info = {
                            "id": actor_id,
                            "name": actor.get("name", "unknown entity"),
                            "type": actor.get("entity_type", "unknown"),
                        }

                        # Check if entity is dead (HP = 0) and mark for special narration (NON-MOVE ACTION)
                        hp = actor.get("hp", {})
                        current_hp = None
                        if isinstance(hp, dict):
                            current_hp = hp.get("current")

                        # Only check for death if we have valid HP data
                        if current_hp is not None and current_hp <= 0:
                            entity_info["is_dead"] = True
                            entity_info["description"] = (
                                f"the body of {entity_info['name']}"
                            )
                        else:
                            entity_info["is_dead"] = False

                        visible_entities.append(entity_info)

            context_zone_id = current_zone_id

        # Get scene atmosphere
        scene = redacted_state.get("scene", {})
        scene_tags = scene.get("tags", {})

        return {
            "pov_actor": {
                "id": pov_id,
                "name": pov_name,
                "hp": pov_actor.get("hp", {}).get("current", "unknown"),
                "max_hp": pov_actor.get("hp", {}).get("max", "unknown"),
            },
            "current_zone": {
                "id": context_zone_id,
                "name": zone_name,
                "description": zone_description,
                "visible_entities": visible_entities,
                "is_first_visit": is_first_visit,  # Add discovery info
            },
            "scene": {
                "round": scene.get("round", 1),
                "tags": scene_tags,
            },
        }

    def _create_prompt(
        self, result: ToolResult, context: Dict[str, Any], previous_narration: str = ""
    ) -> str:
        """Create the prompt for LLM narration generation."""

        # Extract key information
        tool_id = result.tool_id
        facts = result.facts
        narration_hint = result.narration_hint
        effects = result.effects

        # Get tone guidance
        tone_tags = narration_hint.get("tone_tags", [])
        sensory_focus = narration_hint.get("sensory", [])

        # Build effects summary if there are any
        effects_summary = ""
        if effects:
            effects_summary = f"\\nMechanical changes: {len(effects)} effects applied"
            # Add brief summary of major effects
            hp_changes = [e for e in effects if e.get("type") == "hp"]
            if hp_changes:
                effects_summary += f" (including HP changes)"

        # Format visible entities with special handling for dead ones
        entities_description = []
        dead_entities = []
        living_entities = []

        for entity in context["current_zone"]["visible_entities"]:
            if entity.get("is_dead", False):
                dead_entities.append(entity.get("description", entity["name"]))
            else:
                living_entities.append(entity["name"])

        if dead_entities:
            entities_description.append(
                f"CORPSES: {', '.join(dead_entities)} (IMPORTANT: These should be prominently mentioned!)"
            )
        if living_entities:
            entities_description.append(f"Living: {', '.join(living_entities)}")

        entities_text = (
            " | ".join(entities_description) if entities_description else "None"
        )

        # Add previous narration for continuity if provided
        previous_context = ""
        if previous_narration.strip():
            previous_context = (
                f"\n[Previous Narration for Context]:\n{previous_narration.strip()}\n"
            )

        # Add discovery context for zone entries
        discovery_context = ""
        if context["current_zone"]["is_first_visit"]:
            discovery_context = f"\n[IMPORTANT: First Time in Zone] - Use discovery language! Instead of naming the location directly, describe what the character discovers (e.g., 'you find yourself in a vast hall' instead of 'you enter the Great Hall')."

        prompt = dedent(
            f"""
            [Tool Executed]: {tool_id}
            
            [Player Character]: {context['pov_actor']['name']} (HP: {context['pov_actor']['hp']}/{context['pov_actor']['max_hp']})
            
            [Current Location]: {context['current_zone']['name']}
            {context['current_zone']['description']}
            
            [Visible Entities]: {entities_text}
            
            [Scene Atmosphere]: Round {context['scene']['round']}
            Tags: {', '.join([f"{k}={v}" for k, v in context['scene']['tags'].items()]) or 'normal'}
            
            [What Happened - Raw Facts]:
            {json.dumps(facts, indent=2)}
            
            [Tone Guidance]: {', '.join(tone_tags) if tone_tags else 'neutral'}
            [Sensory Focus]: {', '.join(sensory_focus) if sensory_focus else 'visual'}
            
            [Original Summary]: {narration_hint.get('summary', 'No summary provided')}
            {effects_summary}{previous_context}{discovery_context}
            
            NARRATIVE STYLE REQUIREMENTS:
            - Always use 2nd person present tense ("You step", "You see", etc.)
            - Use descriptive language instead of exact names (e.g., "a imposing guard" not "Sleepy Guard", "a grand hall" not "Great Hall")  
            - Be immersive and atmospheric with sensory details
            - Stay true to the mechanical facts but describe them creatively
            
            Write immersive narration for what just happened from the player's perspective.
            Use the tone guidance and sensory focus. Be creative but stay true to the facts.
            {f"Build naturally from the previous narration to create smooth narrative flow." if previous_narration.strip() else ""}
        """
        ).strip()

        return prompt


# Global generator instance
_generator_instance: Optional[NarrationGenerator] = None


def initialize_generator(
    api_key: Optional[str] = None, model: str = "gpt-4o-mini"
) -> None:
    """Initialize the global narration generator."""
    global _generator_instance
    _generator_instance = NarrationGenerator(api_key=api_key, model=model)


def generate_narration(
    result: ToolResult,
    world: GameState,
    pov_actor_id: Optional[str] = None,
    previous_narration: str = "",
) -> str:
    """
    Convenience function to generate narration using the global generator.

    Args:
        result: ToolResult from tool execution
        world: Current game state
        pov_actor_id: Optional POV actor ID

    Returns:
        Rich narrative text
    """
    global _generator_instance
    if _generator_instance is None:
        # Auto-initialize with config defaults
        initialize_generator()

    # Double-check initialization succeeded
    if _generator_instance is None:
        logger.error("Failed to initialize narration generator")
        return result.narration_hint.get("summary", "Something happens.")

    return _generator_instance.generate_narration(
        result, world, pov_actor_id, previous_narration
    )
